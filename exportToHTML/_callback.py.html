<html>
<head>
<title>_callback.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_callback.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">hashlib</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>

<span class="s0">import </span><span class="s1">flask</span>

<span class="s0">from </span><span class="s1">.dependencies </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">handle_callback_args</span><span class="s0">,</span>
    <span class="s1">handle_grouped_callback_args</span><span class="s0">,</span>
    <span class="s1">Output</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">PreventUpdate</span><span class="s0">,</span>
    <span class="s1">WildcardInLongCallback</span><span class="s0">,</span>
    <span class="s1">DuplicateCallback</span><span class="s0">,</span>
    <span class="s1">MissingLongCallbackManagerError</span><span class="s0">,</span>
    <span class="s1">LongCallbackError</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">._grouping </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">flatten_grouping</span><span class="s0">,</span>
    <span class="s1">make_grouping_by_index</span><span class="s0">,</span>
    <span class="s1">grouping_len</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">._utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">create_callback_id</span><span class="s0">,</span>
    <span class="s1">stringify_id</span><span class="s0">,</span>
    <span class="s1">to_json</span><span class="s0">,</span>
    <span class="s1">coerce_to_list</span><span class="s0">,</span>
    <span class="s1">AttributeDict</span><span class="s0">,</span>
    <span class="s1">clean_property_name</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_validate</span>
<span class="s0">from </span><span class="s1">.long_callback.managers </span><span class="s0">import </span><span class="s1">BaseLongCallbackManager</span>
<span class="s0">from </span><span class="s1">._callback_context </span><span class="s0">import </span><span class="s1">context_value</span>


<span class="s0">class </span><span class="s1">NoUpdate:</span>
    <span class="s0">def </span><span class="s1">to_plotly_json(self):  </span><span class="s2"># pylint: disable=no-self-use</span>
        <span class="s0">return </span><span class="s1">{</span><span class="s3">&quot;_dash_no_update&quot;</span><span class="s1">: </span><span class="s3">&quot;_dash_no_update&quot;</span><span class="s1">}</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">is_no_update(obj):</span>
        <span class="s0">return </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">NoUpdate) </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">and </span><span class="s1">obj == {</span><span class="s3">&quot;_dash_no_update&quot;</span><span class="s1">: </span><span class="s3">&quot;_dash_no_update&quot;</span><span class="s1">}</span>
        <span class="s1">)</span>


<span class="s1">GLOBAL_CALLBACK_LIST = []</span>
<span class="s1">GLOBAL_CALLBACK_MAP = {}</span>
<span class="s1">GLOBAL_INLINE_SCRIPTS = []</span>


<span class="s2"># pylint: disable=too-many-locals</span>
<span class="s0">def </span><span class="s1">callback(</span>
    <span class="s1">*_args</span><span class="s0">,</span>
    <span class="s1">background=</span><span class="s0">False,</span>
    <span class="s1">interval=</span><span class="s4">1000</span><span class="s0">,</span>
    <span class="s1">progress=</span><span class="s0">None,</span>
    <span class="s1">progress_default=</span><span class="s0">None,</span>
    <span class="s1">running=</span><span class="s0">None,</span>
    <span class="s1">cancel=</span><span class="s0">None,</span>
    <span class="s1">manager=</span><span class="s0">None,</span>
    <span class="s1">cache_args_to_ignore=</span><span class="s0">None,</span>
    <span class="s1">**_kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Normally used as a decorator, `@dash.callback` provides a server-side 
    callback relating the values of one or more `Output` items to one or 
    more `Input` items which will trigger the callback when they change, 
    and optionally `State` items which provide additional information but 
    do not trigger the callback directly. 
 
    `@dash.callback` is an alternative to `@app.callback` (where `app = dash.Dash()`) 
    introduced in Dash 2.0. 
    It allows you to register callbacks without defining or importing the `app` 
    object. The call signature is identical and it can be used instead of `app.callback` 
    in all cases. 
 
    The last, optional argument `prevent_initial_call` causes the callback 
    not to fire when its outputs are first added to the page. Defaults to 
    `False` and unlike `app.callback` is not configurable at the app level. 
 
    :Keyword Arguments: 
        :param background: 
            Mark the callback as a long callback to execute in a manager for 
            callbacks that take a long time without locking up the Dash app 
            or timing out. 
        :param manager: 
            A long callback manager instance. Currently, an instance of one of 
            `DiskcacheManager` or `CeleryManager`. 
            Defaults to the `background_callback_manager` instance provided to the 
            `dash.Dash constructor`. 
            - A diskcache manager (`DiskcacheManager`) that runs callback 
              logic in a separate process and stores the results to disk using the 
              diskcache library. This is the easiest backend to use for local 
              development. 
            - A Celery manager (`CeleryManager`) that runs callback logic 
              in a celery worker and returns results to the Dash app through a Celery 
              broker like RabbitMQ or Redis. 
        :param running: 
            A list of 3-element tuples. The first element of each tuple should be 
            an `Output` dependency object referencing a property of a component in 
            the app layout. The second element is the value that the property 
            should be set to while the callback is running, and the third element 
            is the value the property should be set to when the callback completes. 
        :param cancel: 
            A list of `Input` dependency objects that reference a property of a 
            component in the app's layout.  When the value of this property changes 
            while a callback is running, the callback is canceled. 
            Note that the value of the property is not significant, any change in 
            value will result in the cancellation of the running job (if any). 
        :param progress: 
            An `Output` dependency grouping that references properties of 
            components in the app's layout. When provided, the decorated function 
            will be called with an extra argument as the first argument to the 
            function.  This argument, is a function handle that the decorated 
            function should call in order to provide updates to the app on its 
            current progress. This function accepts a single argument, which 
            correspond to the grouping of properties specified in the provided 
            `Output` dependency grouping 
        :param progress_default: 
            A grouping of values that should be assigned to the components 
            specified by the `progress` argument when the callback is not in 
            progress. If `progress_default` is not provided, all the dependency 
            properties specified in `progress` will be set to `None` when the 
            callback is not running. 
        :param cache_args_to_ignore: 
            Arguments to ignore when caching is enabled. If callback is configured 
            with keyword arguments (Input/State provided in a dict), 
            this should be a list of argument names as strings. Otherwise, 
            this should be a list of argument indices as integers. 
        :param interval: 
            Time to wait between the long callback update requests. 
    &quot;&quot;&quot;</span>

    <span class="s1">long_spec = </span><span class="s0">None</span>

    <span class="s1">config_prevent_initial_callbacks = _kwargs.pop(</span>
        <span class="s3">&quot;config_prevent_initial_callbacks&quot;</span><span class="s0">, False</span>
    <span class="s1">)</span>
    <span class="s1">callback_map = _kwargs.pop(</span><span class="s3">&quot;callback_map&quot;</span><span class="s0">, </span><span class="s1">GLOBAL_CALLBACK_MAP)</span>
    <span class="s1">callback_list = _kwargs.pop(</span><span class="s3">&quot;callback_list&quot;</span><span class="s0">, </span><span class="s1">GLOBAL_CALLBACK_LIST)</span>

    <span class="s0">if </span><span class="s1">background:</span>
        <span class="s1">long_spec = {</span>
            <span class="s3">&quot;interval&quot;</span><span class="s1">: interval</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">manager:</span>
            <span class="s1">long_spec[</span><span class="s3">&quot;manager&quot;</span><span class="s1">] = manager</span>

        <span class="s0">if </span><span class="s1">progress:</span>
            <span class="s1">long_spec[</span><span class="s3">&quot;progress&quot;</span><span class="s1">] = coerce_to_list(progress)</span>
            <span class="s1">validate_long_inputs(long_spec[</span><span class="s3">&quot;progress&quot;</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">progress_default:</span>
            <span class="s1">long_spec[</span><span class="s3">&quot;progressDefault&quot;</span><span class="s1">] = coerce_to_list(progress_default)</span>

            <span class="s0">if not </span><span class="s1">len(long_spec[</span><span class="s3">&quot;progress&quot;</span><span class="s1">]) == len(long_spec[</span><span class="s3">&quot;progressDefault&quot;</span><span class="s1">]):</span>
                <span class="s0">raise </span><span class="s1">Exception(</span>
                    <span class="s3">&quot;Progress and progress default needs to be of same length&quot;</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">running:</span>
            <span class="s1">long_spec[</span><span class="s3">&quot;running&quot;</span><span class="s1">] = coerce_to_list(running)</span>
            <span class="s1">validate_long_inputs(x[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">long_spec[</span><span class="s3">&quot;running&quot;</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">cancel:</span>
            <span class="s1">cancel_inputs = coerce_to_list(cancel)</span>
            <span class="s1">validate_long_inputs(cancel_inputs)</span>

            <span class="s1">cancels_output = [Output(c.component_id</span><span class="s0">, </span><span class="s3">&quot;id&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">cancel_inputs]</span>

            <span class="s0">try</span><span class="s1">:</span>

                <span class="s1">@callback(cancels_output</span><span class="s0">, </span><span class="s1">cancel_inputs</span><span class="s0">, </span><span class="s1">prevent_initial_call=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s0">def </span><span class="s1">cancel_call(*_):</span>
                    <span class="s1">job_ids = flask.request.args.getlist(</span><span class="s3">&quot;cancelJob&quot;</span><span class="s1">)</span>
                    <span class="s1">executor = (</span>
                        <span class="s1">manager </span><span class="s0">or </span><span class="s1">context_value.get().background_callback_manager</span>
                    <span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">job_ids:</span>
                        <span class="s0">for </span><span class="s1">job_id </span><span class="s0">in </span><span class="s1">job_ids:</span>
                            <span class="s1">executor.terminate_job(job_id)</span>
                    <span class="s0">return </span><span class="s1">NoUpdate()</span>

            <span class="s0">except </span><span class="s1">DuplicateCallback:</span>
                <span class="s0">pass  </span><span class="s2"># Already a callback to cancel, will get the proper jobs from the store.</span>

            <span class="s1">long_spec[</span><span class="s3">&quot;cancel&quot;</span><span class="s1">] = [c.to_dict() </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">cancel_inputs]</span>

        <span class="s0">if </span><span class="s1">cache_args_to_ignore:</span>
            <span class="s1">long_spec[</span><span class="s3">&quot;cache_args_to_ignore&quot;</span><span class="s1">] = cache_args_to_ignore</span>

    <span class="s0">return </span><span class="s1">register_callback(</span>
        <span class="s1">callback_list</span><span class="s0">,</span>
        <span class="s1">callback_map</span><span class="s0">,</span>
        <span class="s1">config_prevent_initial_callbacks</span><span class="s0">,</span>
        <span class="s1">*_args</span><span class="s0">,</span>
        <span class="s1">**_kwargs</span><span class="s0">,</span>
        <span class="s1">long=long_spec</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">validate_long_inputs(deps):</span>
    <span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">deps:</span>
        <span class="s0">if </span><span class="s1">dep.has_wildcard():</span>
            <span class="s0">raise </span><span class="s1">WildcardInLongCallback(</span>
                <span class="s3">f&quot;&quot;&quot;</span>
                <span class="s3">long callbacks does not support dependencies with</span>
                <span class="s3">pattern-matching ids</span>
                    <span class="s3">Received: </span><span class="s0">{</span><span class="s1">repr(dep)</span><span class="s0">}\n</span><span class="s3">&quot;&quot;&quot;</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">clientside_callback(clientside_function</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">return </span><span class="s1">register_clientside_callback(</span>
        <span class="s1">GLOBAL_CALLBACK_LIST</span><span class="s0">,</span>
        <span class="s1">GLOBAL_CALLBACK_MAP</span><span class="s0">,</span>
        <span class="s0">False,</span>
        <span class="s1">GLOBAL_INLINE_SCRIPTS</span><span class="s0">,</span>
        <span class="s1">clientside_function</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">insert_callback(</span>
    <span class="s1">callback_list</span><span class="s0">,</span>
    <span class="s1">callback_map</span><span class="s0">,</span>
    <span class="s1">config_prevent_initial_callbacks</span><span class="s0">,</span>
    <span class="s1">output</span><span class="s0">,</span>
    <span class="s1">outputs_indices</span><span class="s0">,</span>
    <span class="s1">inputs</span><span class="s0">,</span>
    <span class="s1">state</span><span class="s0">,</span>
    <span class="s1">inputs_state_indices</span><span class="s0">,</span>
    <span class="s1">prevent_initial_call</span><span class="s0">,</span>
    <span class="s1">long=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s0">if </span><span class="s1">prevent_initial_call </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">prevent_initial_call = config_prevent_initial_callbacks</span>

    <span class="s1">_validate.validate_duplicate_output(</span>
        <span class="s1">output</span><span class="s0">, </span><span class="s1">prevent_initial_call</span><span class="s0">, </span><span class="s1">config_prevent_initial_callbacks</span>
    <span class="s1">)</span>

    <span class="s1">callback_id = create_callback_id(output</span><span class="s0">, </span><span class="s1">inputs)</span>
    <span class="s1">callback_spec = {</span>
        <span class="s3">&quot;output&quot;</span><span class="s1">: callback_id</span><span class="s0">,</span>
        <span class="s3">&quot;inputs&quot;</span><span class="s1">: [c.to_dict() </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">inputs]</span><span class="s0">,</span>
        <span class="s3">&quot;state&quot;</span><span class="s1">: [c.to_dict() </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">state]</span><span class="s0">,</span>
        <span class="s3">&quot;clientside_function&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s2"># prevent_initial_call can be a string &quot;initial_duplicates&quot;</span>
        <span class="s2"># which should not prevent the initial call.</span>
        <span class="s3">&quot;prevent_initial_call&quot;</span><span class="s1">: prevent_initial_call </span><span class="s0">is True,</span>
        <span class="s3">&quot;long&quot;</span><span class="s1">: long</span>
        <span class="s0">and </span><span class="s1">{</span>
            <span class="s3">&quot;interval&quot;</span><span class="s1">: long[</span><span class="s3">&quot;interval&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">callback_map[callback_id] = {</span>
        <span class="s3">&quot;inputs&quot;</span><span class="s1">: callback_spec[</span><span class="s3">&quot;inputs&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">&quot;state&quot;</span><span class="s1">: callback_spec[</span><span class="s3">&quot;state&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">&quot;outputs_indices&quot;</span><span class="s1">: outputs_indices</span><span class="s0">,</span>
        <span class="s3">&quot;inputs_state_indices&quot;</span><span class="s1">: inputs_state_indices</span><span class="s0">,</span>
        <span class="s3">&quot;long&quot;</span><span class="s1">: long</span><span class="s0">,</span>
        <span class="s3">&quot;output&quot;</span><span class="s1">: output</span><span class="s0">,</span>
        <span class="s3">&quot;raw_inputs&quot;</span><span class="s1">: inputs</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">callback_list.append(callback_spec)</span>

    <span class="s0">return </span><span class="s1">callback_id</span>


<span class="s2"># pylint: disable=R0912, R0915</span>
<span class="s0">def </span><span class="s1">register_callback(  </span><span class="s2"># pylint: disable=R0914</span>
    <span class="s1">callback_list</span><span class="s0">, </span><span class="s1">callback_map</span><span class="s0">, </span><span class="s1">config_prevent_initial_callbacks</span><span class="s0">, </span><span class="s1">*_args</span><span class="s0">, </span><span class="s1">**_kwargs</span>
<span class="s1">):</span>
    <span class="s1">(</span>
        <span class="s1">output</span><span class="s0">,</span>
        <span class="s1">flat_inputs</span><span class="s0">,</span>
        <span class="s1">flat_state</span><span class="s0">,</span>
        <span class="s1">inputs_state_indices</span><span class="s0">,</span>
        <span class="s1">prevent_initial_call</span><span class="s0">,</span>
    <span class="s1">) = handle_grouped_callback_args(_args</span><span class="s0">, </span><span class="s1">_kwargs)</span>
    <span class="s0">if </span><span class="s1">isinstance(output</span><span class="s0">, </span><span class="s1">Output):</span>
        <span class="s2"># Insert callback with scalar (non-multi) Output</span>
        <span class="s1">insert_output = output</span>
        <span class="s1">multi = </span><span class="s0">False</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># Insert callback as multi Output</span>
        <span class="s1">insert_output = flatten_grouping(output)</span>
        <span class="s1">multi = </span><span class="s0">True</span>

    <span class="s1">long = _kwargs.get(</span><span class="s3">&quot;long&quot;</span><span class="s1">)</span>

    <span class="s1">output_indices = make_grouping_by_index(output</span><span class="s0">, </span><span class="s1">list(range(grouping_len(output))))</span>
    <span class="s1">callback_id = insert_callback(</span>
        <span class="s1">callback_list</span><span class="s0">,</span>
        <span class="s1">callback_map</span><span class="s0">,</span>
        <span class="s1">config_prevent_initial_callbacks</span><span class="s0">,</span>
        <span class="s1">insert_output</span><span class="s0">,</span>
        <span class="s1">output_indices</span><span class="s0">,</span>
        <span class="s1">flat_inputs</span><span class="s0">,</span>
        <span class="s1">flat_state</span><span class="s0">,</span>
        <span class="s1">inputs_state_indices</span><span class="s0">,</span>
        <span class="s1">prevent_initial_call</span><span class="s0">,</span>
        <span class="s1">long=long</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s2"># pylint: disable=too-many-locals</span>
    <span class="s0">def </span><span class="s1">wrap_func(func):</span>

        <span class="s0">if </span><span class="s1">long </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">long_key = BaseLongCallbackManager.register_func(</span>
                <span class="s1">func</span><span class="s0">,</span>
                <span class="s1">long.get(</span><span class="s3">&quot;progress&quot;</span><span class="s1">) </span><span class="s0">is not None,</span>
                <span class="s1">callback_id</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">@wraps(func)</span>
        <span class="s0">def </span><span class="s1">add_context(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">output_spec = kwargs.pop(</span><span class="s3">&quot;outputs_list&quot;</span><span class="s1">)</span>
            <span class="s1">app_callback_manager = kwargs.pop(</span><span class="s3">&quot;long_callback_manager&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">callback_ctx = kwargs.pop(</span><span class="s3">&quot;callback_context&quot;</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">callback_manager = long </span><span class="s0">and </span><span class="s1">long.get(</span><span class="s3">&quot;manager&quot;</span><span class="s0">, </span><span class="s1">app_callback_manager)</span>
            <span class="s1">_validate.validate_output_spec(insert_output</span><span class="s0">, </span><span class="s1">output_spec</span><span class="s0">, </span><span class="s1">Output)</span>

            <span class="s1">context_value.set(callback_ctx)</span>

            <span class="s1">func_args</span><span class="s0">, </span><span class="s1">func_kwargs = _validate.validate_and_group_input_args(</span>
                <span class="s1">args</span><span class="s0">, </span><span class="s1">inputs_state_indices</span>
            <span class="s1">)</span>

            <span class="s1">response = {</span><span class="s3">&quot;multi&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

            <span class="s0">if </span><span class="s1">long </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">callback_manager:</span>
                    <span class="s0">raise </span><span class="s1">MissingLongCallbackManagerError(</span>
                        <span class="s3">&quot;Running `long` callbacks requires a manager to be installed.</span><span class="s0">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;Available managers:</span><span class="s0">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;- Diskcache (`pip install dash[diskcache]`) to run callbacks in a separate Process&quot;</span>
                        <span class="s3">&quot; and store results on the local filesystem.</span><span class="s0">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;- Celery (`pip install dash[celery]`) to run callbacks in a celery worker&quot;</span>
                        <span class="s3">&quot; and store results on redis.</span><span class="s0">\n</span><span class="s3">&quot;</span>
                    <span class="s1">)</span>

                <span class="s1">progress_outputs = long.get(</span><span class="s3">&quot;progress&quot;</span><span class="s1">)</span>
                <span class="s1">cache_key = flask.request.args.get(</span><span class="s3">&quot;cacheKey&quot;</span><span class="s1">)</span>
                <span class="s1">job_id = flask.request.args.get(</span><span class="s3">&quot;job&quot;</span><span class="s1">)</span>
                <span class="s1">old_job = flask.request.args.getlist(</span><span class="s3">&quot;oldJob&quot;</span><span class="s1">)</span>

                <span class="s1">current_key = callback_manager.build_cache_key(</span>
                    <span class="s1">func</span><span class="s0">,</span>
                    <span class="s2"># Inputs provided as dict is kwargs.</span>
                    <span class="s1">func_args </span><span class="s0">if </span><span class="s1">func_args </span><span class="s0">else </span><span class="s1">func_kwargs</span><span class="s0">,</span>
                    <span class="s1">long.get(</span><span class="s3">&quot;cache_args_to_ignore&quot;</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s0">if </span><span class="s1">old_job:</span>
                    <span class="s0">for </span><span class="s1">job </span><span class="s0">in </span><span class="s1">old_job:</span>
                        <span class="s1">callback_manager.terminate_job(job)</span>

                <span class="s0">if not </span><span class="s1">cache_key:</span>
                    <span class="s1">cache_key = current_key</span>

                    <span class="s1">job_fn = callback_manager.func_registry.get(long_key)</span>

                    <span class="s1">job = callback_manager.call_job_fn(</span>
                        <span class="s1">cache_key</span><span class="s0">,</span>
                        <span class="s1">job_fn</span><span class="s0">,</span>
                        <span class="s1">func_args </span><span class="s0">if </span><span class="s1">func_args </span><span class="s0">else </span><span class="s1">func_kwargs</span><span class="s0">,</span>
                        <span class="s1">AttributeDict(</span>
                            <span class="s1">args_grouping=callback_ctx.args_grouping</span><span class="s0">,</span>
                            <span class="s1">using_args_grouping=callback_ctx.using_args_grouping</span><span class="s0">,</span>
                            <span class="s1">outputs_grouping=callback_ctx.outputs_grouping</span><span class="s0">,</span>
                            <span class="s1">using_outputs_grouping=callback_ctx.using_outputs_grouping</span><span class="s0">,</span>
                            <span class="s1">inputs_list=callback_ctx.inputs_list</span><span class="s0">,</span>
                            <span class="s1">states_list=callback_ctx.states_list</span><span class="s0">,</span>
                            <span class="s1">outputs_list=callback_ctx.outputs_list</span><span class="s0">,</span>
                            <span class="s1">input_values=callback_ctx.input_values</span><span class="s0">,</span>
                            <span class="s1">state_values=callback_ctx.state_values</span><span class="s0">,</span>
                            <span class="s1">triggered_inputs=callback_ctx.triggered_inputs</span><span class="s0">,</span>
                            <span class="s1">ignore_register_page=</span><span class="s0">True,</span>
                        <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">)</span>

                    <span class="s1">data = {</span>
                        <span class="s3">&quot;cacheKey&quot;</span><span class="s1">: cache_key</span><span class="s0">,</span>
                        <span class="s3">&quot;job&quot;</span><span class="s1">: job</span><span class="s0">,</span>
                    <span class="s1">}</span>

                    <span class="s1">running = long.get(</span><span class="s3">&quot;running&quot;</span><span class="s1">)</span>

                    <span class="s0">if </span><span class="s1">running:</span>
                        <span class="s1">data[</span><span class="s3">&quot;running&quot;</span><span class="s1">] = {str(r[</span><span class="s4">0</span><span class="s1">]): r[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">running}</span>
                        <span class="s1">data[</span><span class="s3">&quot;runningOff&quot;</span><span class="s1">] = {str(r[</span><span class="s4">0</span><span class="s1">]): r[</span><span class="s4">2</span><span class="s1">] </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">running}</span>
                    <span class="s1">cancel = long.get(</span><span class="s3">&quot;cancel&quot;</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">cancel:</span>
                        <span class="s1">data[</span><span class="s3">&quot;cancel&quot;</span><span class="s1">] = cancel</span>

                    <span class="s1">progress_default = long.get(</span><span class="s3">&quot;progressDefault&quot;</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">progress_default:</span>
                        <span class="s1">data[</span><span class="s3">&quot;progressDefault&quot;</span><span class="s1">] = {</span>
                            <span class="s1">str(o): x</span>
                            <span class="s0">for </span><span class="s1">o</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">zip(progress_outputs</span><span class="s0">, </span><span class="s1">progress_default)</span>
                        <span class="s1">}</span>
                    <span class="s0">return </span><span class="s1">to_json(data)</span>
                <span class="s0">if </span><span class="s1">progress_outputs:</span>
                    <span class="s2"># Get the progress before the result as it would be erased after the results.</span>
                    <span class="s1">progress = callback_manager.get_progress(cache_key)</span>
                    <span class="s0">if </span><span class="s1">progress:</span>
                        <span class="s1">response[</span><span class="s3">&quot;progress&quot;</span><span class="s1">] = {</span>
                            <span class="s1">str(x): progress[i] </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(progress_outputs)</span>
                        <span class="s1">}</span>

                <span class="s1">output_value = callback_manager.get_result(cache_key</span><span class="s0">, </span><span class="s1">job_id)</span>
                <span class="s2"># Must get job_running after get_result since get_results terminates it.</span>
                <span class="s1">job_running = callback_manager.job_running(job_id)</span>
                <span class="s0">if not </span><span class="s1">job_running </span><span class="s0">and </span><span class="s1">output_value </span><span class="s0">is </span><span class="s1">callback_manager.UNDEFINED:</span>
                    <span class="s2"># Job canceled -&gt; no output to close the loop.</span>
                    <span class="s1">output_value = NoUpdate()</span>

                <span class="s0">elif </span><span class="s1">(</span>
                    <span class="s1">isinstance(output_value</span><span class="s0">, </span><span class="s1">dict)</span>
                    <span class="s0">and </span><span class="s3">&quot;long_callback_error&quot; </span><span class="s0">in </span><span class="s1">output_value</span>
                <span class="s1">):</span>
                    <span class="s1">error = output_value.get(</span><span class="s3">&quot;long_callback_error&quot;</span><span class="s1">)</span>
                    <span class="s0">raise </span><span class="s1">LongCallbackError(</span>
                        <span class="s3">f&quot;An error occurred inside a long callback: </span><span class="s0">{</span><span class="s1">error[</span><span class="s3">'msg'</span><span class="s1">]</span><span class="s0">}\n{</span><span class="s1">error[</span><span class="s3">'tb'</span><span class="s1">]</span><span class="s0">}</span><span class="s3">&quot;</span>
                    <span class="s1">)</span>

                <span class="s0">if </span><span class="s1">job_running </span><span class="s0">and </span><span class="s1">output_value </span><span class="s0">is not </span><span class="s1">callback_manager.UNDEFINED:</span>
                    <span class="s2"># cached results.</span>
                    <span class="s1">callback_manager.terminate_job(job_id)</span>

                <span class="s0">if </span><span class="s1">multi </span><span class="s0">and </span><span class="s1">isinstance(output_value</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
                    <span class="s1">output_value = [</span>
                        <span class="s1">NoUpdate() </span><span class="s0">if </span><span class="s1">NoUpdate.is_no_update(r) </span><span class="s0">else </span><span class="s1">r</span>
                        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">output_value</span>
                    <span class="s1">]</span>

                <span class="s0">if </span><span class="s1">output_value </span><span class="s0">is </span><span class="s1">callback_manager.UNDEFINED:</span>
                    <span class="s0">return </span><span class="s1">to_json(response)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># don't touch the comment on the next line - used by debugger</span>
                <span class="s1">output_value = func(*func_args</span><span class="s0">, </span><span class="s1">**func_kwargs)  </span><span class="s2"># %% callback invoked %%</span>

            <span class="s0">if </span><span class="s1">NoUpdate.is_no_update(output_value):</span>
                <span class="s0">raise </span><span class="s1">PreventUpdate</span>

            <span class="s0">if not </span><span class="s1">multi:</span>
                <span class="s1">output_value</span><span class="s0">, </span><span class="s1">output_spec = [output_value]</span><span class="s0">, </span><span class="s1">[output_spec]</span>
                <span class="s1">flat_output_values = output_value</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(output_value</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
                    <span class="s2"># For multi-output, allow top-level collection to be</span>
                    <span class="s2"># list or tuple</span>
                    <span class="s1">output_value = list(output_value)</span>

                <span class="s2"># Flatten grouping and validate grouping structure</span>
                <span class="s1">flat_output_values = flatten_grouping(output_value</span><span class="s0">, </span><span class="s1">output)</span>

            <span class="s1">_validate.validate_multi_return(</span>
                <span class="s1">output_spec</span><span class="s0">, </span><span class="s1">flat_output_values</span><span class="s0">, </span><span class="s1">callback_id</span>
            <span class="s1">)</span>

            <span class="s1">component_ids = collections.defaultdict(dict)</span>
            <span class="s1">has_update = </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">val</span><span class="s0">, </span><span class="s1">spec </span><span class="s0">in </span><span class="s1">zip(flat_output_values</span><span class="s0">, </span><span class="s1">output_spec):</span>
                <span class="s0">if </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">NoUpdate):</span>
                    <span class="s0">continue</span>
                <span class="s0">for </span><span class="s1">vali</span><span class="s0">, </span><span class="s1">speci </span><span class="s0">in </span><span class="s1">(</span>
                    <span class="s1">zip(val</span><span class="s0">, </span><span class="s1">spec) </span><span class="s0">if </span><span class="s1">isinstance(spec</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">else </span><span class="s1">[[val</span><span class="s0">, </span><span class="s1">spec]]</span>
                <span class="s1">):</span>
                    <span class="s0">if not </span><span class="s1">isinstance(vali</span><span class="s0">, </span><span class="s1">NoUpdate):</span>
                        <span class="s1">has_update = </span><span class="s0">True</span>
                        <span class="s1">id_str = stringify_id(speci[</span><span class="s3">&quot;id&quot;</span><span class="s1">])</span>
                        <span class="s1">prop = clean_property_name(speci[</span><span class="s3">&quot;property&quot;</span><span class="s1">])</span>
                        <span class="s1">component_ids[id_str][prop] = vali</span>

            <span class="s0">if not </span><span class="s1">has_update:</span>
                <span class="s0">raise </span><span class="s1">PreventUpdate</span>

            <span class="s1">response[</span><span class="s3">&quot;response&quot;</span><span class="s1">] = component_ids</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">jsonResponse = to_json(response)</span>
            <span class="s0">except </span><span class="s1">TypeError:</span>
                <span class="s1">_validate.fail_callback_output(output_value</span><span class="s0">, </span><span class="s1">output)</span>

            <span class="s0">return </span><span class="s1">jsonResponse</span>

        <span class="s1">callback_map[callback_id][</span><span class="s3">&quot;callback&quot;</span><span class="s1">] = add_context</span>

        <span class="s0">return </span><span class="s1">func</span>

    <span class="s0">return </span><span class="s1">wrap_func</span>


<span class="s1">_inline_clientside_template = </span><span class="s3">&quot;&quot;&quot; 
var clientside = window.dash_clientside = window.dash_clientside || {{}}; 
var ns = clientside[&quot;{namespace}&quot;] = clientside[&quot;{namespace}&quot;] || {{}}; 
ns[&quot;{function_name}&quot;] = {clientside_function}; 
&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">register_clientside_callback(</span>
    <span class="s1">callback_list</span><span class="s0">,</span>
    <span class="s1">callback_map</span><span class="s0">,</span>
    <span class="s1">config_prevent_initial_callbacks</span><span class="s0">,</span>
    <span class="s1">inline_scripts</span><span class="s0">,</span>
    <span class="s1">clientside_function</span><span class="s0">,</span>
    <span class="s1">*args</span><span class="s0">,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s1">output</span><span class="s0">, </span><span class="s1">inputs</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">prevent_initial_call = handle_callback_args(args</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s1">insert_callback(</span>
        <span class="s1">callback_list</span><span class="s0">,</span>
        <span class="s1">callback_map</span><span class="s0">,</span>
        <span class="s1">config_prevent_initial_callbacks</span><span class="s0">,</span>
        <span class="s1">output</span><span class="s0">,</span>
        <span class="s0">None,</span>
        <span class="s1">inputs</span><span class="s0">,</span>
        <span class="s1">state</span><span class="s0">,</span>
        <span class="s0">None,</span>
        <span class="s1">prevent_initial_call</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s2"># If JS source is explicitly given, create a namespace and function</span>
    <span class="s2"># name, then inject the code.</span>
    <span class="s0">if </span><span class="s1">isinstance(clientside_function</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">namespace = </span><span class="s3">&quot;_dashprivate_clientside_funcs&quot;</span>
        <span class="s2"># Create a hash from the function, it will be the same always</span>
        <span class="s1">function_name = hashlib.md5(clientside_function.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)).hexdigest()</span>

        <span class="s1">inline_scripts.append(</span>
            <span class="s1">_inline_clientside_template.format(</span>
                <span class="s1">namespace=namespace</span><span class="s0">,</span>
                <span class="s1">function_name=function_name</span><span class="s0">,</span>
                <span class="s1">clientside_function=clientside_function</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2"># Callback is stored in an external asset.</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">namespace = clientside_function.namespace</span>
        <span class="s1">function_name = clientside_function.function_name</span>

    <span class="s1">callback_list[-</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;clientside_function&quot;</span><span class="s1">] = {</span>
        <span class="s3">&quot;namespace&quot;</span><span class="s1">: namespace</span><span class="s0">,</span>
        <span class="s3">&quot;function_name&quot;</span><span class="s1">: function_name</span><span class="s0">,</span>
    <span class="s1">}</span>
</pre>
</body>
</html>